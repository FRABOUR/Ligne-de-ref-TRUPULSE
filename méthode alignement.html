<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <title>Distance point-droite avec incertitude</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      max-width: 750px;
      margin: 30px auto;
      padding: 0 10px;
      position: relative;
    }
    label, input, select {
      display: block;
      margin-top: 10px;
    }
    canvas {
      border: 1px solid #ccc;
      background: #f9f9f9;
      display: block;
      margin: 20px auto;
    }
    #logoPage {
      position: absolute;
      top: 50px;
      right: 10px;
      width: 200px;
    }
    #resultats {
      font-weight: bold;
      color: darkblue;
      margin-top: 15px;
    }
  </style>
</head>
<body>

<img id="logoPage" src="logo.png" alt="Logo" />
<h2>Calcul de la distance d'un point à une droite avec incertitude</h2>

<label>Azimut A : <input type="number" id="angleA" value="327.12"></label>
<label>Distance A : <input type="number" id="distA" value="151.11"></label>
<label>Distance AB : <input type="number" id="distanceAB" value="100"></label>
<label>Azimut C : <input type="number" id="angleC" value="7.15"></label>
<label>Distance C : <input type="number" id="distC" value="52.54"></label>
<label>Unité des angles :
  <select id="angleUnite">
    <option value="deg">degrés (°)</option>
    <option value="grad" selected>grades (gon)</option>
  </select>
</label>

<label>Incertitude angulaire (gon) : <input type="number" id="incertAngle" value="0.01"></label>
<label>Incertitude distance (m) : <input type="number" id="incertDist" value="0.01"></label>
<label><input type="checkbox" id="useUncertainty"> Utiliser les incertitudes</label>

<button onclick="calculer()">Calculer</button>
<div id="resultats"></div>
<canvas id="canvas" width="700" height="500"></canvas>

<script>
function toRad(gon, unit) {
  return unit === "grad" ? Math.PI / 2 - (gon * Math.PI / 200) : Math.PI / 2 - (gon * Math.PI / 180);
}

function polarToCartesian(angle, dist, unit) {
  const rad = toRad(angle, unit);
  return { x: dist * Math.cos(rad), y: dist * Math.sin(rad) };
}

function projOrth(A, B, C) {
  const ABx = B.x - A.x, ABy = B.y - A.y;
  const ACx = C.x - A.x, ACy = C.y - A.y;
  const t = (ACx * ABx + ACy * ABy) / (ABx*ABx + ABy*ABy);
  return { x: A.x + t * ABx, y: A.y + t * ABy };
}

function distPtDroite(A, B, C) {
  const num = Math.abs((B.y - A.y) * C.x - (B.x - A.x) * C.y + B.x * A.y - B.y * A.x);
  const den = Math.sqrt((B.y - A.y)**2 + (B.x - A.x)**2);
  return den !== 0 ? num / den : 0;
}

function distance(A, B) {
  return Math.sqrt((B.x - A.x)**2 + (B.y - A.y)**2);
}

function calculer() {
  const unit = document.getElementById("angleUnite").value;
  const aA = parseFloat(document.getElementById("angleA").value);
  const dA = parseFloat(document.getElementById("distA").value);
  const aC = parseFloat(document.getElementById("angleC").value);
  const dC = parseFloat(document.getElementById("distC").value);
  const dAB = parseFloat(document.getElementById("distanceAB").value);
  const incA = parseFloat(document.getElementById("incertAngle").value);
  const incD = parseFloat(document.getElementById("incertDist").value);
  const useInc = document.getElementById("useUncertainty").checked;
  const ctx = document.getElementById("canvas").getContext("2d");

  const A = polarToCartesian(aA, dA, unit);
  const dir = polarToCartesian(aA, 1, unit);
  const B = { x: A.x + dir.x * dAB, y: A.y + dir.y * dAB };
  const C = polarToCartesian(aC, dC, unit);
  const H = projOrth(A, B, C);

  const dExact = distPtDroite(A, B, C);
  let ecartType = 0;

  if (useInc) {
    const N = 5000;
    let dists = [];
    for (let i = 0; i < N; i++) {
      const aA_ = aA + incA * (Math.random() - 0.5) * 2;
      const dA_ = dA + incD * (Math.random() - 0.5) * 2;
      const aC_ = aC + incA * (Math.random() - 0.5) * 2;
      const dC_ = dC + incD * (Math.random() - 0.5) * 2;
      const AA = polarToCartesian(aA_, dA_, unit);
      const dirB = polarToCartesian(aA_, 1, unit);
      const BB = { x: AA.x + dirB.x * dAB, y: AA.y + dirB.y * dAB };
      const CC = polarToCartesian(aC_, dC_, unit);
      dists.push(distPtDroite(AA, BB, CC));
    }
    const mean = dists.reduce((a,b) => a + b, 0) / N;
    ecartType = Math.sqrt(dists.reduce((s,d) => s + (d - mean)**2, 0) / N);
  }

  document.getElementById("resultats").innerHTML =
    `Distance de C à AB : ${dExact.toFixed(2)} m` +
    (useInc ? ` ± ${ecartType.toFixed(2)} m` : "");

  // Dessin
  ctx.clearRect(0, 0, 700, 500);
  const pts = [A, B, C, H];
  const xs = pts.map(p => p.x), ys = pts.map(p => p.y);
  const scale = 300 / Math.max(Math.max(...xs) - Math.min(...xs), Math.max(...ys) - Math.min(...ys));
  const offsetX = 350, offsetY = 250;
  function drawPt(p, color, label) {
    const x = offsetX + p.x * scale;
    const y = offsetY - p.y * scale;
    ctx.fillStyle = color;
    ctx.beginPath(); ctx.arc(x, y, 5, 0, 2 * Math.PI); ctx.fill();
    ctx.fillText(label, x + 6, y - 6);
  }
  function line(p1, p2, color) {
    ctx.strokeStyle = color; ctx.beginPath();
    ctx.moveTo(offsetX + p1.x*scale, offsetY - p1.y*scale);
    ctx.lineTo(offsetX + p2.x*scale, offsetY - p2.y*scale); ctx.stroke();
  }
  drawPt(A, "blue", "A");
  drawPt(B, "blue", "B");
  drawPt(C, "red", "C");
  drawPt(H, "green", "H");
  line(A, B, "blue");
  ctx.setLineDash([5,5]); line(C, H, "red"); ctx.setLineDash([]);
}
</script>
</body>
</html>
