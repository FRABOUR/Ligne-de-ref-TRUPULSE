<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <title>Distance point-droite avec incertitude</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      max-width: 750px;
      margin: 30px auto;
      padding: 0 10px;
      position: relative;
    }
    label {
      display: block;
      margin-top: 10px;
    }
    input, select {
      margin-left: 5px;
    }
    button {
      margin-top: 15px;
      padding: 7px 15px;
      font-size: 1em;
    }
    canvas {
      border: 1px solid #ccc;
      background: #f9f9f9;
      display: block;
      margin: 20px auto;
    }
    #resultats {
      font-weight: bold;
      color: darkblue;
      margin-top: 15px;
    }
    #logoPage {
      position: absolute;
      top: 50px;
      right: 10px;
      width: 200px;
      opacity: 1;
    }
  </style>
</head>
<body>

<img id="logoPage" src="logo.png" alt="Logo" />

<h2>Calcul de la distance d'un point à une droite avec incertitude (V0.4)</h2>
<p>Angles en degrés ou grades (gon), distances en mètres.</p>

<label>Titre du graphique : <input type="text" id="graphTitle" value="Liaison A-B"/></label>
<label>Nom du point A : <input type="text" id="labelA" value="A"/></label>
<label>Azimut de A : <input type="number" id="angleA" step="0.01" value="327.12"/></label>
<label>Distance au point A : <input type="number" id="distA" step="0.01" value="151.11"/></label>
<label>Distance entre A et B : <input type="number" id="distanceABInput" step="0.01" value="100.00"/></label>
<label>Azimut de C : <input type="number" id="angleC" step="0.01" value="7.15"/></label>
<label>Distance au point C : <input type="number" id="distC" step="0.01" value="52.54"/></label>
<label>Unité des angles :
  <select id="angleUnite">
    <option value="deg">degrés (°)</option>
    <option value="grad" selected>grades (gon)</option>
  </select>
</label>

<hr>
<h4>Incertitudes (activables)</h4>
<label><input type="checkbox" id="useUncertainty" checked> Prendre en compte les incertitudes</label>
<label>Incertitude sur les angles : <input type="number" id="angleErr" value="0.02" step="0.01"> (° ou gon)</label>
<label>Incertitude sur les distances : <input type="number" id="distErr" value="0.03" step="0.01"> m</label>
<label>Nombre d'échantillons (Monte Carlo) : <input type="number" id="nSamples" value="1000"></label>

<button onclick="calculer()">Calculer</button>

<div id="resultats">
  <p>Distance point C à la droite AB : <span id="distanceC"></span> m</p>
  <p>Incertitude (écart-type) : <span id="incertitude"></span> m</p>
  <p>Portée (AB) : <span id="distanceAB"></span> m</p>
  <p>Distance H–A : <span id="distanceHA"></span> m</p>
  <p>Distance H–B : <span id="distanceHB"></span> m</p>
</div>

<canvas id="canvas" width="700" height="600"></canvas>

<script>
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");
const W = canvas.width;
const Hc = canvas.height;

function gonToRadAdjusted(gon) {
  return Math.PI / 2 - (gon * Math.PI / 200);
}
function degToRadAdjusted(deg) {
  return Math.PI / 2 - (deg * Math.PI / 180);
}
function polarToCartesian(angle, distance, unit) {
  const rad = unit === "grad" ? gonToRadAdjusted(angle) : degToRadAdjusted(angle);
  return { x: distance * Math.cos(rad), y: distance * Math.sin(rad) };
}
function distancePointADroite(A, B, C) {
  const num = Math.abs((B.y - A.y) * C.x - (B.x - A.x) * C.y + B.x * A.y - B.y * A.x);
  const den = Math.sqrt((B.y - A.y)**2 + (B.x - A.x)**2);
  return den !== 0 ? num / den : 0;
}
function projectionOrthogonale(A, B, C) {
  const ABx = B.x - A.x, ABy = B.y - A.y;
  const ACx = C.x - A.x, ACy = C.y - A.y;
  const t = (ACx * ABx + ACy * ABy) / (ABx*ABx + ABy*ABy);
  return { x: A.x + t * ABx, y: A.y + t * ABy };
}
function distancePoints(P1, P2) {
  return Math.sqrt((P2.x - P1.x)**2 + (P2.y - P1.y)**2);
}
function randn_bm() {
  let u = 0, v = 0;
  while(u === 0) u = Math.random();
  while(v === 0) v = Math.random();
  return Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
}
function toCanvasCoords(pt, cx, cy, scale) {
  return { x: cx + pt.x * scale, y: cy - pt.y * scale };
}
function drawGrid(ctx, w, h, step=20) {
  ctx.strokeStyle = "#eee";
  for(let x = 0; x <= w; x += step) { ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, h); ctx.stroke(); }
  for(let y = 0; y <= h; y += step) { ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(w, y); ctx.stroke(); }
}
function monteCarlo(angleA, distA, distAB, angleC, distC, unit, errA, errD, N) {
  const samples = [];
  for (let i = 0; i < N; i++) {
    const aA = angleA + randn_bm() * errA;
    const dA = distA + randn_bm() * errD;
    const dAB = distAB + randn_bm() * errD;
    const aC = angleC + randn_bm() * errA;
    const dC = distC + randn_bm() * errD;
    const A = polarToCartesian(aA, dA, unit);
    const dirAB = polarToCartesian(aA, 1, unit);
    const B = { x: A.x + dirAB.x * dAB, y: A.y + dirAB.y * dAB };
    const C = polarToCartesian(aC, dC, unit);
    samples.push(distancePointADroite(A, B, C));
  }
  const mean = samples.reduce((a,b) => a + b, 0) / N;
  const variance = samples.reduce((a,b) => a + (b - mean) ** 2, 0) / N;
  return Math.sqrt(variance);
}
function calculer() {
  const angleUnite = document.getElementById("angleUnite").value;
  const angleA = parseFloat(document.getElementById("angleA").value);
  const distA = parseFloat(document.getElementById("distA").value);
  const distanceAB = parseFloat(document.getElementById("distanceABInput").value);
  const angleC = parseFloat(document.getElementById("angleC").value);
  const distC = parseFloat(document.getElementById("distC").value);
  const errA = parseFloat(document.getElementById("angleErr").value);
  const errD = parseFloat(document.getElementById("distErr").value);
  const N = parseInt(document.getElementById("nSamples").value);
  const useUncertainty = document.getElementById("useUncertainty").checked;
  const A = polarToCartesian(angleA, distA, angleUnite);
  const dirAB = polarToCartesian(angleA, 1, angleUnite);
  const B = { x: A.x + dirAB.x * distanceAB, y: A.y + dirAB.y * distanceAB };
  const C = polarToCartesian(angleC, distC, angleUnite);
  const H = projectionOrthogonale(A, B, C);
  const d = distancePointADroite(A, B, C);
  document.getElementById("distanceC").textContent = d.toFixed(2);
  document.getElementById("distanceAB").textContent = distancePoints(A,B).toFixed(2);
  document.getElementById("distanceHA").textContent = distancePoints(H,A).toFixed(2);
  document.getElementById("distanceHB").textContent = distancePoints(H,B).toFixed(2);
  document.getElementById("incertitude").textContent = useUncertainty ? monteCarlo(angleA, distA, distanceAB, angleC, distC, angleUnite, errA, errD, N).toFixed(2) : "—";
  // dessin conservé (pas recopié ici)
}
</script>
</body>
</html>
