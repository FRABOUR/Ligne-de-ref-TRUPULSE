<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <title>Distance d'un point à une droite V2</title>
  <style>
    body { font-family: Arial, sans-serif; max-width: 700px; margin: auto; }
    canvas { border: 1px solid black; margin-top: 20px; }
    label { display: block; margin-top: 10px; }
    input, select { margin-left: 5px; }
    span.result { font-weight: bold; color: darkblue; }
  </style>
</head>
<body>
  <h2>Calcul de la distance d'un point à une droite</h2>

  <label>Angle A : <input type="number" id="angleA" /></label>
  <label>Distance A : <input type="number" id="distA" /></label>

  <label>Angle B : <input type="number" id="angleB" /></label>
  <label>Distance B : <input type="number" id="distB" /></label>

  <label>Angle C : <input type="number" id="angleC" /></label>
  <label>Distance C : <input type="number" id="distC" /></label>

  <label>Unité des angles :
    <select id="angleUnite">
      <option value="deg">Degrés (°)</option>
      <option value="grad" selected>Grades (gon)</option>
    </select>
  </label>

  <button onclick="calculer()">Calculer</button>

  <p>
    AB = <span class="result" id="distAB">-</span> m<br>
    Distance de C à AB = <span class="result" id="distCtoAB">-</span> m
  </p>

  <canvas id="canvas" width="600" height="600"></canvas>

  <script>
    function degToRad(val, unit) {
      return val * Math.PI / (unit === "deg" ? 180 : 200);
    }

    function polarToCartesianX(angle, dist, unit) {
      return dist * Math.cos(degToRad(angle, unit));
    }

    function polarToCartesianY(angle, dist, unit) {
      return dist * Math.sin(degToRad(angle, unit));
    }

    function projectionSurDroite(xA, yA, xB, yB, xC, yC) {
      const dx = xB - xA;
      const dy = yB - yA;
      const t = ((xC - xA) * dx + (yC - yA) * dy) / (dx * dx + dy * dy);
      return [xA + t * dx, yA + t * dy];
    }

    function calculer() {
      const aA = parseFloat(document.getElementById("angleA").value);
      const dA = parseFloat(document.getElementById("distA").value);
      const aB = parseFloat(document.getElementById("angleB").value);
      const dB = parseFloat(document.getElementById("distB").value);
      const aC = parseFloat(document.getElementById("angleC").value);
      const dC = parseFloat(document.getElementById("distC").value);
      const unit = document.getElementById("angleUnite").value;

      const xA = polarToCartesianX(aA, dA, unit);
      const yA = polarToCartesianY(aA, dA, unit);
      const xB = polarToCartesianX(aB, dB, unit);
      const yB = polarToCartesianY(aB, dB, unit);
      const xC = polarToCartesianX(aC, dC, unit);
      const yC = polarToCartesianY(aC, dC, unit);

      const distAB = Math.hypot(xB - xA, yB - yA);
      const num = Math.abs((yB - yA) * xC - (xB - xA) * yC + xB * yA - yB * xA);
      const den = Math.hypot(yB - yA, xB - xA);
      const distCtoAB = num / den;

      const [xP, yP] = projectionSurDroite(xA, yA, xB, yB, xC, yC);
      const canvas = document.getElementById("canvas");
      const ctx = canvas.getContext("2d");
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Centrage automatique
      const points = [[xA, yA], [xB, yB], [xC, yC], [xP, yP], [0, 0]];
      const minX = Math.min(...points.map(p => p[0]));
      const maxX = Math.max(...points.map(p => p[0]));
      const minY = Math.min(...points.map(p => p[1]));
      const maxY = Math.max(...points.map(p => p[1]));

      const margin = 40;
      const drawableWidth = canvas.width - 2 * margin;
      const drawableHeight = canvas.height - 2 * margin;

      const scaleX = drawableWidth / (maxX - minX || 1);
      const scaleY = drawableHeight / (maxY - minY || 1);
      const scale = Math.min(scaleX, scaleY);

      const offsetX = margin + (drawableWidth - (maxX - minX) * scale) / 2 - minX * scale;
      const offsetY = margin + (drawableHeight - (maxY - minY) * scale) / 2 + maxY * scale;

      function drawPoint(x, y, color, label) {
        ctx.beginPath();
        ctx.arc(offsetX + x * scale, offsetY - y * scale, 4, 0, 2 * Math.PI);
        ctx.fillStyle = color;
        ctx.fill();
        ctx.fillText(label, offsetX + x * scale + 6, offsetY - y * scale - 6);
      }

      function drawGrid() {
        const step = 10;
        ctx.strokeStyle = "#ccc";
        ctx.lineWidth = 0.5;
        for (let x = Math.floor(minX / step) * step; x <= maxX; x += step) {
          ctx.beginPath();
          ctx.moveTo(offsetX + x * scale, 0);
          ctx.lineTo(offsetX + x * scale, canvas.height);
          ctx.stroke();
        }
        for (let y = Math.floor(minY / step) * step; y <= maxY; y += step) {
          ctx.beginPath();
          ctx.moveTo(0, offsetY - y * scale);
          ctx.lineTo(canvas.width, offsetY - y * scale);
          ctx.stroke();
        }
      }

      drawGrid();

      // Droite AB
      ctx.beginPath();
      ctx.moveTo(offsetX + xA * scale, offsetY - yA * scale);
      ctx.lineTo(offsetX + xB * scale, offsetY - yB * scale);
      ctx.strokeStyle = "blue";
      ctx.lineWidth = 2;
      ctx.stroke();

      // Hauteur CP
      ctx.beginPath();
      ctx.setLineDash([5, 5]);
      ctx.moveTo(offsetX + xC * scale, offsetY - yC * scale);
      ctx.lineTo(offsetX + xP * scale, offsetY - yP * scale);
      ctx.strokeStyle = "red";
      ctx.stroke();
      ctx.setLineDash([]);

      drawPoint(xA, yA, "blue", "A");
      drawPoint(xB, yB, "blue", "B");
      drawPoint(xC, yC, "red", "C");
      drawPoint(xP, yP, "black", "P");
      drawPoint(0, 0, "black", "O");

      document.getElementById("distAB").textContent = distAB.toFixed(2);
      document.getElementById("distCtoAB").textContent = distCtoAB.toFixed(2);
    }
  </script>
</body>
</html>
